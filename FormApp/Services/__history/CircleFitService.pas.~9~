unit CircleFitService;

interface

uses
  Matrix, SysUtils, Math, MatrixConst;

type
  TCircleFitResult = record
    Center2D: TDoubleMatrix;  // 1×2 matrix: [a, b]
    Radius: Double;
  end;

// Fits a circle (x - a)^2 + (y - b)^2 = r^2 to 2D points
function FitCircle2D(const Points2D: TDoubleMatrix): TCircleFitResult;

implementation

function FitCircle2D(const Points2D: TDoubleMatrix): TCircleFitResult;
var
  N, i: Integer;
  A, D, Sol, PinvA: TDoubleMatrix;
  x, y, aVal, bVal, rVal: Double;
begin

  Writeln('FitCircle2D');

  // Expecting Points2D to be 2×N
  if Points2D.Height <> 2 then
    raise Exception.Create('FitCircle2D: Input must be a 2×N matrix.');

  N := Points2D.Width;

  // Design matrix A: [x; y; 1] shape: 3×N
  A := TDoubleMatrix.Create(3, N);
  D := TDoubleMatrix.Create(1, N);

  Writeln(Format('Points2D Size: %d rows × %d columns', [Points2D.Height, Points2D.Width]));

  for i := 0 to N - 1 do
  begin
    x := Points2D[i, 0];
    y := Points2D[i, 1];

    A[0, i] := x;
    A[1, i] := y;
    A[2, i] := 1.0;

    D[0, i] := Sqr(x) + Sqr(y);
  end;

  PinvA := TDoubleMatrix.Create;
  if A.PseudoInversion(PinvA) <> srOk then
    raise Exception.Create('Pseudo-inversion of A failed.');

  Sol := PinvA.Mult(D);  // shape: 3×1  [2a; 2b; a² + b² - r²]

  aVal := 0.5 * Sol[0, 0];
  bVal := 0.5 * Sol[0, 1];
  rVal := Sqrt(Sol[0, 2] + Sqr(aVal) + Sqr(bVal));

  Result.Center2D := TDoubleMatrix.Create(1, 2);  // Store as row vector
  Result.Center2D[0, 0] := aVal;
  Result.Center2D[0, 1] := bVal;
  Result.Radius := rVal;

  // Cleanup
  A.Free;
  D.Free;
  Sol.Free;
  PinvA.Free;
end;

end.

