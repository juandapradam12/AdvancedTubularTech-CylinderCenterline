unit StripeDetectionService;

interface

uses
  SysUtils, Math, Matrix;

type
  TStripe = record
    Points: TDoubleMatrix; // 3×N matrix containing the points of this stripe
  end;

  TStripeArray = array of TStripe;

/// <summary>
/// Detect stripes along the axis direction using gaps between sorted projected points.
/// </summary>
/// <param name="RawPoints">3×N matrix of input points</param>
/// <param name="AxisDirIn">3×1 cylinder axis direction</param>
/// <param name="MeanVecIn">3×1 mean vector</param>
/// <param name="GapThreshold">optional manual threshold (0 = adaptive)</param>
function DetectStripes(
  const RawPoints, AxisDirIn, MeanVecIn: TDoubleMatrix;
  GapThreshold: Double = 0): TStripeArray;

implementation

// ------------------------------------------------------------
// Debug utilities
// ------------------------------------------------------------
procedure DebugMatrixShape(const Name: string; const M: TDoubleMatrix);
begin
  if M = nil then
    Writeln(Name, ' = nil')
  else
    Writeln(Format('%s Size: %d rows × %d cols', [Name, M.Height, M.Width]));
end;

function Ensure3xN(const M: TDoubleMatrix; const Name: string): TDoubleMatrix;
begin
  if M = nil then
    raise Exception.Create(Name + ' is nil.');

  // If input is Nx3, transpose it
  if (M.Width = 3) and (M.Height <> 3) then
  begin
    Writeln(Name + ' appears to be N×3. Transposing to 3×N...');
    Exit(M.Transpose);
  end;

  // If already 3×N
  if (M.Height = 3) then
    Exit(M);

  raise Exception.Create(Name + ' must be 3×N or N×3.');
end;

function Ensure3x1(const M: TDoubleMatrix; const Name: string): TDoubleMatrix;
begin
  if M = nil then
    raise Exception.Create(Name + ' is nil.');
  if (M.Height = 3) and (M.Width = 1) then
    Exit(M);
  if (M.Width = 3) and (M.Height = 1) then
  begin
    Writeln(Name + ' appears to be 1×3. Transposing to 3×1...');
    Exit(M.Transpose);
  end;
  raise Exception.Create(Name + ' must be 3×1 or 1×3.');
end;

// ------------------------------------------------------------
// Main detection
// ------------------------------------------------------------
function DetectStripes(
  const RawPoints, AxisDirIn, MeanVecIn: TDoubleMatrix;
  GapThreshold: Double): TStripeArray;
var
  Points, AxisDir, MeanVec: TDoubleMatrix;
  N, i, j, k: Integer;
  ProjVals: array of Double;
  SortedIdx: array of Integer;
  Diffs: array of Double;
  MeanGap, StdGap: Double;
  Labels: array of Integer;
  StripeCounts: array of Integer;
  CurrentLabel: Integer;
begin
  Writeln('--- [StripeDetectionService] ---');

  // Validate and reshape inputs
  Points := Ensure3xN(RawPoints, 'Points');
  AxisDir := Ensure3x1(AxisDirIn, 'AxisDir');
  MeanVec := Ensure3x1(MeanVecIn, 'MeanVec');

  DebugMatrixShape('Points', Points);
  DebugMatrixShape('AxisDir', AxisDir);
  DebugMatrixShape('MeanVec', MeanVec);

  N := Points.Width;
  if N < 3 then
    raise Exception.Create('Not enough points for stripe detection.');

  // Project each point onto axis
  SetLength(ProjVals, N);
  for i := 0 to N - 1 do
  begin
    ProjVals[i] :=
      (Points[i, 0] - MeanVec[0, 0]) * AxisDir[0, 0] +
      (Points[i, 1] - MeanVec[0, 1]) * AxisDir[0, 1] +
      (Points[i, 2] - MeanVec[0, 2]) * AxisDir[0, 2];
  end;

  // Sort indices by projection values
  SetLength(SortedIdx, N);
  for i := 0 to N - 1 do SortedIdx[i] := i;
  for i := 0 to N - 2 do
    for j := i + 1 to N - 1 do
      if ProjVals[SortedIdx[i]] > ProjVals[SortedIdx[j]] then
      begin
        k := SortedIdx[i];
        SortedIdx[i] := SortedIdx[j];
        SortedIdx[j] := k;
      end;

  // Compute diffs
  SetLength(Diffs, N - 1);
  for i := 0 to N - 2 do
    Diffs[i] := ProjVals[SortedIdx[i + 1]] - ProjVals[SortedIdx[i]];

  // Adaptive threshold
  if GapThreshold <= 0 then
  begin
    MeanGap := 0;
    for i := 0 to High(Diffs) do
      MeanGap := MeanGap + Diffs[i];
    MeanGap := MeanGap / Max(1, Length(Diffs));

    StdGap := 0;
    for i := 0 to High(Diffs) do
      StdGap := StdGap + Sqr(Diffs[i] - MeanGap);
    StdGap := Sqrt(StdGap / Max(1, Length(Diffs)));

    GapThreshold := MeanGap + 3 * StdGap;
  end;
  Writeln(Format('GapThreshold: %.6f', [GapThreshold]));

  // Label stripes
  SetLength(Labels, N);
  CurrentLabel := 0;
  Labels[SortedIdx[0]] := CurrentLabel;
  for i := 0 to N - 2 do
  begin
    if Diffs[i] > GapThreshold then
      Inc(CurrentLabel);
    Labels[SortedIdx[i + 1]] := CurrentLabel;
  end;
  Writeln(Format('Total stripes detected: %d', [CurrentLabel + 1]));

  // Count points per stripe
  SetLength(StripeCounts, CurrentLabel + 1);
  for i := 0 to N - 1 do
    Inc(StripeCounts[Labels[i]]);

  // Allocate and fill stripes
  SetLength(Result, CurrentLabel + 1);
  for i := 0 to High(Result) do
  begin
    Writeln(Format('Allocating Stripe %d with %d points', [i, StripeCounts[i]]));
    Result[i].Points := TDoubleMatrix.Create(3, StripeCounts[i]);
  end;

  // Reset counters for fill
  FillChar(StripeCounts[0], Length(StripeCounts) * SizeOf(Integer), 0);

  for i := 0 to N - 1 do
  begin
    k := Labels[i];
    Writeln('k = ', k);
    Result[k].Points[0, StripeCounts[k]] := Points[i, 0];
    Result[k].Points[1, StripeCounts[k]] := Points[i, 1];
    Result[k].Points[2, StripeCounts[k]] := Points[i, 2];
    Inc(StripeCounts[k]);
  end;

  // Debug each stripe
  for i := 0 to High(Result) do
  begin
    DebugMatrixShape(Format('Stripe %d Points', [i]), Result[i].Points);
  end;
end;

end.

