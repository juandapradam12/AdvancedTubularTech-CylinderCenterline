unit CircleFitService;

interface

uses
  Matrix, SysUtils, Math, MatrixConst;

type
  TCircleFitResult = record
    Center2D: TDoubleMatrix;  // 1×2 matrix: [a, b]
    Radius: Double;
    Residual: Double;         // Sum of squared distance errors
  end;

// Fits a circle (x - a)^2 + (y - b)^2 = r^2 to 2D points
function FitCircle2D(const Points2D: TDoubleMatrix): TCircleFitResult;

implementation

function FitCircle2D(const Points2D: TDoubleMatrix): TCircleFitResult;
var
  N, i: Integer;
  A, D, Sol, PinvA: TDoubleMatrix;
  x, y, aVal, bVal, rVal, dx, dy, dist, error, residualSum: Double;
begin
  if Points2D.Height <> 2 then
    Points2D := Points2D.Transpose; //raise Exception.Create('FitCircle2D: Input must be a 2×N matrix.');

  N := Points2D.Width;

  A := TDoubleMatrix.Create(3, N);
  D := TDoubleMatrix.Create(1, N);

  for i := 0 to N - 1 do
  begin
    x := Points2D[i, 0];
    y := Points2D[i, 1];

    A[0, i] := x;
    A[1, i] := y;
    A[2, i] := 1.0;

    D[0, i] := Sqr(x) + Sqr(y);
  end;

  PinvA := TDoubleMatrix.Create;
  if A.PseudoInversion(PinvA) <> srOk then
    raise Exception.Create('Pseudo-inversion of A failed.');

  Sol := PinvA.Mult(D);  // [2a; 2b; a² + b² - r²]

  aVal := 0.5 * Sol[0, 0];
  bVal := 0.5 * Sol[0, 1];
  rVal := Sqrt(Sol[0, 2] + Sqr(aVal) + Sqr(bVal));

  // Compute residual
  residualSum := 0.0;
  for i := 0 to N - 1 do
  begin
    dx := Points2D[i, 0] - aVal;
    dy := Points2D[i, 1] - bVal;
    dist := Sqrt(Sqr(dx) + Sqr(dy));
    error := dist - rVal;
    residualSum := residualSum + Sqr(error);
  end;

  Result.Center2D := TDoubleMatrix.Create(1, 2);
  Result.Center2D[0, 0] := aVal;
  Result.Center2D[0, 1] := bVal;
  Result.Radius := rVal;
  Result.Residual := residualSum;

  // Cleanup
  A.Free;
  D.Free;
  Sol.Free;
  PinvA.Free;
end;

end.

