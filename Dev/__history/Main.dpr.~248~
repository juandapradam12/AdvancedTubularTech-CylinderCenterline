program Main;

{$APPTYPE CONSOLE}
{$R *.res}

uses
  SysUtils,
  Matrix,
  MtxTimer,
  ReadDataUtils,
  PCAService,
  PCAProjectionService,
  CircleFitService,
  PCAMultiPlaneIterationService,
  CylinderLengthService,
  InterceptService,
  SmartInterceptService,
  StripeDetectionService,
  PCAMultiAxisIteratorService,
  SymmetryArgumentService;

//

procedure CylinderPipeline;
var
  StartTime: Int64;
  EndTime: Int64;
  DeltaTime: Double;
  DeltaTimeStr: string;

  FolderPath, FileName: string;

  Points: TDoubleMatrix;
  AxisDirection: TDoubleMatrix;
  PCAResult: TPCAResult;

  ScoredPlanes: TPlaneScoreArray;
  i, j, s: Integer;

  PlaneScores: TPlaneScoreArray;
  BestPlane: TPlaneScoreRecord;

  LiftedCenter, Intercept: TDoubleMatrix;
  LengthEstimate, Radius, LOD: Double;

  Mean, ReorderedMean: TDoubleMatrix;
  StripeResult: TStripeResult;

  AxisResults: TAxisStripeInfoArray;


  AxisDir: TDoubleMatrix;

  BestSymmetryResult: TCylinderSymmetryResult;


begin
  //////// CYLINDER CENTERLINE ALGORITHM ////////

  Writeln('Cylinder Centerline Algorithm');
  Writeln(' ');
  Writeln('Starting ...');
  Writeln(' ');

  //// START TIMER ////
  StartTime := MtxGetTime;

  //// READ POINT CLOUD ////
  Writeln('---- Read Point Cloud ----');
  Writeln(' ');

  //FolderPath := 'C:\Users\SKG Tecnología\Documents\ATTInc-CylinderCenterline\Data\'; //20250625 JDPM Test Results\';
  //FolderPath := 'C:\Users\SKG Tecnología\Documents\ATTInc-CylinderCenterline\Data\20250625 JDPM Test Results\';
  FolderPath := 'C:\Users\SKG Tecnología\Documents\AdvancedTubularTech-CylinderCenterline\Dev\Data\VTube-LASER 6 Point Cylinders\';

  //FileName := 'Point Cloud - 3 inch OD - Single Cylinder.txt';
  //FileName := 'Point Cloud - 0.25 inch OD - Single Cylinder.TXT';
  //FileName := 'Point Cloud - 2.75 inch OD - Single Cylinder - Short - Exhaust Pipe - Straight 1.txt';
  //FileName := 'Point Cloud - 2.75 inch OD - Single Cylinder Super Short Two Stripes.txt';
  //FileName := 'Point Cloud - 76.2 mm OD - 188 points total.txt';
  //FileName := 'Point Cloud - 76.2 mm OD - 25 points total.txt';
  //FileName := '8 Points Test - In Z Axis.txt';
  //FileName := '6 Points Test - In Z Axis.txt';
  //FileName := '5 Points Test In Z Axis'  + '.txt';

  FileName := 'Point Cloud-Juan Test Data - 6 points - Close to XY plane - 10.5 Apart - 82.4 OD.TXT';

  Writeln('FileName: ', FileName);

  Points := ReadPointCloudFromFile(FolderPath + FileName);
  if Points = nil then
  begin
    Writeln('Failed to load point cloud.');
    Exit;
  end;

  if (Points.Height <> 3) and (Points.Width = 3) then
    Points := Points.Transpose;

  Writeln(Format('Point Cloud Size: %d rows × %d columns', [Points.Height, Points.Width]));
  Writeln(' ');


  //// CONTINOUS MAPPING FIT ////
  ///

  // PCA //
  PCAResult := PerformPCA(Points, 1.0);

  // MULTI-PLANE ITERATION //
  PlaneScores := ScoreAllPCAPlanes(Points, PCAResult.EigenVectors, PCAResult.MeanVector);

  // BEST PLANE SELECTION //
  BestPlane := SelectBestPlaneFromScores(PlaneScores);

  // Radius //
  Radius := BestPlane.Radius;

  // AXIS DIRECTION //
  AxisDirection := GetCylinderAxisFromBestPlane(PCAResult.EigenVectors, BestPlane);

  // CENTER LIFTING //
  LiftedCenter := Lift2DCenterTo3D(BestPlane.Center2D, PCAResult.MeanVector, PCAResult.EigenVectors, BestPlane.DimX, BestPlane.DimY);

  // Z INTERCEPT //
  Intercept := ComputeSmartIntercept(LiftedCenter, AxisDirection);

  // LENGTH ESTIMATE //
  LengthEstimate := EstimateCylinderLength(Points, AxisDirection);

  // L/OD Ratio //
  LOD := LengthEstimate / (2.0 * Radius);  // L / OD

  //// PRINT IN TERMINAL Continous Mapping Fit ////

  Writeln('---- Continous Mapping Fit ----');
  Writeln(' ');

  Writeln(Format('Axis Direction  = (%.4f, %.4f, %.4f)', [
    AxisDirection[0, 0],
    AxisDirection[1, 0],
    AxisDirection[2, 0]]));

  Writeln(Format('Radius          = %.4f', [BestPlane.Radius]));

  Writeln(Format('Intercept     = (%.4f, %.4f, %.4f)',
    [Intercept[0, 0], Intercept[1, 0], Intercept[2, 0]]));

  Writeln(' ');

  Writeln(Format('Length Estimate = %.3f', [LengthEstimate]));
  Writeln(Format('L/OD Ratio      = %.4f', [LOD]));

  Writeln(' ');


  //// SYMMETRICAL FIT ////
  ///

  // Compute projections and fit circles for all planes
  PlaneScores := ScoreAllPCAPlanes(Points, PCAResult.EigenVectors, PCAResult.MeanVector);

  // Select the best axis using symmetry-based logic
  BestSymmetryResult := SelectCylinderBySymmetry(Points, PlaneScores,  PCAResult.MeanVector, PCAResult.EigenVectors);

  // L/OD Ratio //
  LOD := LengthEstimate / (2.0 * Radius);  // L / OD

  // PRINT IN TERMINAL SYMMETRIC FIT //

  Writeln('---- Symmetrical Fit ----');
  Writeln(' ');

  Writeln(Format('Axis Direction = (%.4f, %.4f, %.4f)', [
    BestSymmetryResult.AxisDirection[0,0],
    BestSymmetryResult.AxisDirection[1,0],
    BestSymmetryResult.AxisDirection[2,0]
  ]));

  Writeln(Format('Fitted Radius = %.4f', [BestSymmetryResult.Radius]));
  Writeln(Format('Intercept = (%.4f, %.4f, %.4f)', [
    BestSymmetryResult.ZIntercept[0,0],
    BestSymmetryResult.ZIntercept[1,0],
    BestSymmetryResult.ZIntercept[2,0]
  ]));

  Writeln(' ');

  Writeln(Format('Length Estimate = %.4f', [BestSymmetryResult.LengthEstimate]));
  Writeln(Format('L/OD Ratio      = %.4f', [LOD]));

  Writeln(' ');


  // END TIMER
  EndTime := MtxGetTime;
  DeltaTime := (EndTime - StartTime) / mtxFreq;
  DeltaTimeStr := FloatToStr(DeltaTime);


  Writeln('---- Timing ----');
  Writeln(' ');
  Writeln('Execution Time = ' + DeltaTimeStr + ' s');
  Writeln('Success!');
  Writeln(' ');
end;


begin
  try
    CylinderPipeline;
  except
    on E: Exception do
      Writeln(E.ClassName, ': ', E.Message);
  end;

  WriteLn('Press Enter to exit...');
  ReadLn;
end.


