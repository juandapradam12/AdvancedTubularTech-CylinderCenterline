unit PCAMultiPlaneIterationService;

interface

uses
  Matrix;

type
  TPlaneScoreRecord = record
    DimX, DimY: Integer;
    Projection2D: TDoubleMatrix;
    Center2D: TDoubleMatrix;
    Radius: Double;
    Residual: Double;
    RadiusMean: Double;
    RadiusStd: Double;
  end;

  TPlaneScoreArray = array of TPlaneScoreRecord;

function ScoreAllPCAPlanes(
  const Points, EigenVectors, MeanVector: TDoubleMatrix
): TPlaneScoreArray;

function SelectBestPlaneFromScores(
  const Scores: TPlaneScoreArray
): TPlaneScoreRecord;

implementation

uses
  SysUtils, Math, PCAProjectionService, CircleFitService;

function ComputeRadiusStats(
  const Points2D: TDoubleMatrix;
  CenterX, CenterY: Double;
  out MeanR, StdR: Double
): Boolean;
var
  i: Integer;
  dx, dy, r, sumR, sumSq, n: Double;
begin
  sumR := 0;
  sumSq := 0;
  n := Points2D.Width;

  for i := 0 to Points2D.Width - 1 do
  begin
    dx := Points2D[i, 0] - CenterX;
    dy := Points2D[i, 1] - CenterY;
    r := Sqrt(Sqr(dx) + Sqr(dy));

    sumR := sumR + r;
    sumSq := sumSq + r * r;
  end;

  MeanR := sumR / n;
  StdR := Sqrt((sumSq / n) - Sqr(MeanR));
  Result := True;
end;

function ScoreAllPCAPlanes(
  const Points, EigenVectors, MeanVector: TDoubleMatrix
): TPlaneScoreArray;
const
  DimPairs: array[0..2, 0..1] of Integer = ((0, 1), (0, 2), (1, 2));
var
  i: Integer;
  Proj: TDoubleMatrix;
  Fit: TCircleFitResult;
  RMean, RStd: Double;
begin
  SetLength(Result, 3);

  for i := 0 to 2 do
  begin
    Result[i].DimX := DimPairs[i][0];
    Result[i].DimY := DimPairs[i][1];

    Proj := ProjectToPlane(Points, EigenVectors, MeanVector, Result[i].DimX, Result[i].DimY);
    Result[i].Projection2D := Proj;

    Fit := FitCircle2D(Proj);

    Result[i].Center2D := TDoubleMatrix.Create(2, 1);
    Result[i].Center2D[0, 0] := Fit.Center2D[0, 0];
    Result[i].Center2D[1, 0] := Fit.Center2D[0, 1];

    Result[i].Radius := Fit.Radius;
    Result[i].Residual := Fit.Residual;

    ComputeRadiusStats(Proj, Fit.Center2D[0, 0], Fit.Center2D[1, 0], RMean, RStd);
    Result[i].RadiusMean := RMean;
    Result[i].RadiusStd := RStd;
  end;
end;

function SelectBestPlaneFromScores(
  const Scores: TPlaneScoreArray
): TPlaneScoreRecord;
var
  i: Integer;
  BestIndex: Integer;
  BestResidual, BestStd, BestRadiusDiff, RadiusDiff: Double;
begin
  if Length(Scores) = 0 then
    raise Exception.Create('No PCA plane scores provided.');

  BestIndex := -1;
  BestResidual := MaxDouble;
  BestStd := MaxDouble;
  BestRadiusDiff := MaxDouble;

  for i := 0 to High(Scores) do
  begin
    RadiusDiff := Abs(Scores[i].Radius - Scores[i].RadiusMean);

    if (Scores[i].Residual < BestResidual) and
       (Scores[i].RadiusStd < BestStd) and
       (RadiusDiff < BestRadiusDiff) then
    begin
      BestResidual := Scores[i].Residual;
      BestStd := Scores[i].RadiusStd;
      BestRadiusDiff := RadiusDiff;
      BestIndex := i;
    end;
  end;

  if BestIndex = -1 then
    raise Exception.Create('No suitable PCA plane found.');

  Result := Scores[BestIndex];
end;

end.

