unit ZInterceptService;

interface

uses
  Matrix;

function Lift2DCenterTo3D(
  const Center2D: TDoubleMatrix;
  const MeanVector: TDoubleMatrix;
  const EigenVectors: TDoubleMatrix;
  DimX, DimY: Integer
): TDoubleMatrix;

function ComputeZIntercept(
  const LiftedCenter, AxisDirection: TDoubleMatrix
): TDoubleMatrix;

function ReorderMeanVector(
  const OriginalMean: TDoubleMatrix;
  DimX, DimY, DimZ: Integer
): TDoubleMatrix;


function ComputeZInterceptDim(
  const LiftedCenter, AxisDirection: TDoubleMatrix;
  DimZ: Integer
): TDoubleMatrix;

implementation

uses
  SysUtils, Math;

function ReorderMeanVector(
  const OriginalMean: TDoubleMatrix;
  DimX, DimY, DimZ: Integer
): TDoubleMatrix;
begin
  // Return a 3×1 vector re-ordered to match DimX, DimY, DimZ // X, Y, Z // Z, X, Y // Z, Y, X  //
  // X, Z, Y  // Y, Z, X // Y, X, Z
  Result := TDoubleMatrix.Create(1, 3);

  Result[0, 0] := OriginalMean[0, DimZ];
  Result[0, 1] := OriginalMean[0, DimX];
  Result[0, 2] := OriginalMean[0, DimY];
end;


function Lift2DCenterTo3D(
  const Center2D: TDoubleMatrix;
  const MeanVector: TDoubleMatrix;
  const EigenVectors: TDoubleMatrix;
  DimX, DimY: Integer
): TDoubleMatrix;
var
  U, W: array[0..2] of Double;
  i: Integer;
begin

  Writeln('Lift2DCenterTo3D');


  // Extract U and W directions from PCA eigenvectors
  for i := 0 to 2 do
  begin
    U[i] := EigenVectors[DimX, i];
    W[i] := EigenVectors[DimY, i];
  end;

  Writeln(Format('U  = (%.4f, %.4f, %.4f)', [U[0], U[1], U[2]]));
  Writeln(Format('W  = (%.4f, %.4f, %.4f)', [W[0], W[1], W[2]]));

  Writeln(Format('MeanVector Size  = (%d, %d)', [
    MeanVector.Height, MeanVector.Width]));

  Writeln(Format('MeanVector  = (%.4f, %.4f, %.4f)', [MeanVector[0, 0], MeanVector[0, 1], MeanVector[0, 2]]));

  // Lift to 3D using mean vector and PCA directions
  Result := TDoubleMatrix.Create(3, 1);
  for i := 0 to 2 do
  begin

    Result[i, 0] := MeanVector[0, i] +
                    Center2D[0, 0] * U[i] +
                    Center2D[1, 0] * W[i];
  end;
end;

function ComputeZIntercept(
  const LiftedCenter, AxisDirection: TDoubleMatrix
): TDoubleMatrix;
var
  vz, t: Double;
begin

  Writeln('ComputeZIntercept');


  Result := TDoubleMatrix.Create(3, 1);
  vz := AxisDirection[2, 0];

  if Abs(vz) < 1e-8 then
    raise Exception.Create('Axis direction is parallel to the XY plane. No Z-intercept possible.');

  t := -LiftedCenter[2, 0] / vz;

  Writeln('t = ', t);

  Writeln(Format('LiftedCenter  = (%.4f, %.4f, %.4f)', [LiftedCenter[0, 0],
    LiftedCenter[1, 0], LiftedCenter[2, 0]]));

  Writeln(Format('AxisDirection  = (%.4f, %.4f, %.4f)', [AxisDirection[0, 0],
    AxisDirection[1, 0], AxisDirection[2, 0]]));

  Result[0, 0] := LiftedCenter[0, 0] + t * AxisDirection[0, 0];
  Result[1, 0] := LiftedCenter[1, 0] + t * AxisDirection[1, 0];
  Result[2, 0] := LiftedCenter[2, 0] + t * AxisDirection[2, 0];//0;
end;


function ComputeZInterceptDim(
  const LiftedCenter, AxisDirection: TDoubleMatrix;
   DimZ: Integer
): TDoubleMatrix;
var
  vz, t: Double;
  i: Integer;
begin

  Writeln('ComputeZInterceptDim');

  Writeln(' ');

  Writeln('DimZ = ', DimZ);

  Result := TDoubleMatrix.Create(3, 1);

  vz := AxisDirection[DimZ, 0];

  Writeln(Format('LiftedCenter = (%.4f, %.4f, %.4f)', [LiftedCenter[0, 0],
    LiftedCenter[1, 0], LiftedCenter[2, 0]]));

  LiftedCenter[0, 0] := LiftedCenter[1, 0];
  LiftedCenter[1, 0] := LiftedCenter[2, 0];
  LiftedCenter[2, 0] := LiftedCenter[0, 0];

  Writeln(Format('LiftedCenter Reordered = (%.4f, %.4f, %.4f)', [LiftedCenter[0, 0],
    LiftedCenter[1, 0], LiftedCenter[2, 0]]));

  if Abs(vz) < 1e-8 then
    raise Exception.Create('Axis direction is parallel to the selected Z plane. No intercept possible.');

  t := -LiftedCenter[DimZ, 0] / vz;
  Writeln('t = ', t);

  Result[0, 0] := LiftedCenter[0, 0] + t * AxisDirection[0, 0];
  Result[1, 0] := LiftedCenter[1, 0] + t * AxisDirection[1, 0];
  Result[2, 0] := LiftedCenter[2, 0] + t * AxisDirection[2, 0];
end;


end.

