unit SmartInterceptService;

interface

uses
  Matrix;

function ComputeSmartIntercept(
  const LiftedCenter, AxisDirection: TDoubleMatrix
): TDoubleMatrix;

implementation

uses
  SysUtils, Math, InterceptService;

function VectorNorm(const V: TDoubleMatrix): Double;
begin
  Result := Sqrt(Sqr(V[0, 0]) + Sqr(V[1, 0]) + Sqr(V[2, 0]));
end;

function IsAxisParallelToZ(const AxisDir: TDoubleMatrix; Tolerance: Double = 0.01): Boolean;
var
  DotProd, Norm, CosAngle: Double;
begin
  Norm := VectorNorm(AxisDir);
  if Norm = 0 then
    raise Exception.Create('Zero-length axis vector');

  DotProd := AxisDir[2, 0];  // dot product with unit Z
  CosAngle := Abs(DotProd / Norm);  // = cos(theta)

  Writeln('CosAngle = ', CosAngle);

  Result := Abs(CosAngle - 1.0) < Tolerance;
end;

function ComputeSmartIntercept(
  const LiftedCenter, AxisDirection: TDoubleMatrix
): TDoubleMatrix;
var
  t, vy: Double;
begin
  if IsAxisParallelToZ(AxisDirection) then
  begin
    Writeln('Parallel to Z');
    // Fallback: intersect with Y=0 plane instead
    vy := AxisDirection[1, 0];

    if Abs(vy) < 1e-8 then
      raise Exception.Create('Axis is parallel to both Z and Y planes. No valid intercept.');

    t := -LiftedCenter[1, 0] / vy;

    Result := TDoubleMatrix.Create(3, 1);
    Result[0, 0] := LiftedCenter[0, 0] + t * AxisDirection[0, 0];
    Result[1, 0] := LiftedCenter[1, 0] + t * AxisDirection[1, 0];
    Result[2, 0] := LiftedCenter[2, 0] + t * AxisDirection[2, 0];
  end
  else
  begin
    Writeln('Not Parallel to Z');
    // Delegate to ZInterceptService for general case
    Result := ComputeIntercept(LiftedCenter, AxisDirection);
  end;
end;

end.




